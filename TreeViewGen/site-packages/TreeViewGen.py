from io import StringIO

def generate_treeview(lines):
    """生成目录树结构文本并返回字符串
    参数：
        lines - 包含父子关系的字符串列表，每个字符串格式为"父节点 子节点"
    返回值：
        生成的目录树文本字符串（包含所有错误信息）"""
    
    buffer = StringIO()
    tree = {}
    root = None
    has_root = False

    for line in lines:
        line = line.strip()
        if not line:
            break
        
        parts = line.split()
        if len(parts) != 2:
            print(f"Error: Invalid input format. Each line must contain two strings separated by space.", file=buffer)
            continue
        
        parent, child = parts

        # 处理第一个节点作为根节点
        if not has_root:
            # 初始化根节点
            root = parent
            has_root = True
            if parent not in tree:
                tree[parent] = []
            
            # 检查重复子节点
            if child in tree[parent]:
                print(f"Error: Duplicate child '{child}' under parent '{parent}'.", file=buffer)
                continue
            
            tree[parent].append(child)
            if child not in tree:
                tree[child] = []
        else:
            # 处理后续节点
            if parent not in tree:
                print(f"Error: Parent '{parent}' does not exist.", file=buffer)
                continue
            
            if child in tree[parent]:
                print(f"Error: Duplicate child '{child}' under parent '{parent}'.", file=buffer)
                continue
            
            tree[parent].append(child)
            if child not in tree:
                tree[child] = []

    # 检查根节点是否存在
    if not has_root:
        print("Error: No root node provided.", file=buffer)
        return buffer.getvalue()

    # 生成目录树文本
    print(root, file=buffer)
    _generate_tree_lines(root, "", False, tree, buffer)

    return buffer.getvalue()

def _generate_tree_lines(node, prefix, is_last, tree, buffer):
    """递归生成目录树文本的辅助函数"""
    children = tree.get(node, [])
    for i, child in enumerate(children):
        is_last_child = i == len(children) - 1
        connector = "└─ " if is_last_child else "├─ "
        print(f"{prefix}{connector}{child}", file=buffer)
        
        # 处理空节点保持树形结构
        child_children = tree.get(child, [])
        if not child_children and not is_last_child:
            print(f"{prefix}│", file=buffer)
        
        # 生成新的前缀并递归
        new_prefix = prefix + ("    " if is_last_child else "│   ")
        _generate_tree_lines(child, new_prefix, is_last_child, tree, buffer)

# 保留原始命令行功能
if __name__ == "__main__":
    import sys
    input_lines = []
    for line in sys.stdin:
        stripped = line.strip()
        input_lines.append(line)  # 保留原始换行符处理
        if not stripped:
            break
    result = generate_treeview(input_lines)
    print(result)